% !TEX root = hazelnut-dynamics.tex
\vspace{-5px}
\newcommand{\relatedWorkSection}{Related and Future Work}
\section{\protect\relatedWorkSection} % don't like the all-caps thing that the template does, so protecting it from that
\label{sec:relatedWork}
\vspace{-2px}

This paper defined a dynamic semantics for incomplete functional programs
based directly on the static semantics developed by \citet{popl-paper}. That paper, as well as a subsequent ``vision paper'' introducing \Hazel, suggested as future work  
a corresponding dynamic semantics for the purposes of live programming \cite{HazelnutSNAPL}. 
This paper    
develops the conceptual and type-theoretic details necessary to achieve this broader vision.

The semantics borrows machinery related to type holes from gradual type theory \cite{Siek06a,DBLP:conf/snapl/SiekVCB15}, as discussed
at length in Sec.~\ref{sec:calculus}. The main innovation relative to this
prior work is the treatment of cast failures as holes, rather than errors.
Many of the methods developed to make gradual typing more expressive and practical are directly relevant to future directions for \Hazel and other implementations of the ideas herein \cite{takikawa_et_al:LIPIcs:2015:5215}. For example, there has been substantial work on the problem of implementing casts efficiently, e.g. by \citet{herman2010space}, and on integrating gradual typing with polymorphism \cite{DBLP:conf/esop/XieBO18,Igarashi:2017:PGT:3136534.3110284}, and with refinement types \cite{DBLP:conf/popl/LehmannT17}. Another direction that we leave to future work is the integration of these ideas into dependently typed proof assistants, 
where evaluation is at the service of equational reasoning \cite{DBLP:journals/corr/abs-1009-2789}. Several modern proof assistants, e.g. Agda \cite{norell2009dependently,norell:thesis}, Idris \cite{brady2013idris} and Beluga \cite{DBLP:conf/flops/Pientka10} already provide initial syntactic and static support for holes (see Sec.~\ref{sec:intro}).

Although our expectation is that \Hazel will remain a pure functional language \emph{a la} \Elm~or Haskell, another interesting future direction would be to move beyond
pure functional programming and carefully integrate imperative features, e.g. ML-style references. These require particular care, as recognized by \citet{Siek06a} and \citet{DBLP:conf/esop/SiekVCTG15}, but the techniques are known and we see no reason why the type safety properties  established in this paper would not be conserved, with suitable modifications to account for a store. Going beyond references to incorporate external effects, e.g. IO effects, raises some important practical concerns, however---we do not want to continue past a hole or error and in so doing haphazardly trigger an unintended effect. In this setting, it is likely better to explicitly ask the programmer whether to continue evaluation past a hole or cast failure. More generally, the small step specification in this paper is suitable as the basis for a single stepper, which generalizes evaluation. \citet{ocaml-stepper} discuss some unresolved usability issues relevant to single steppers for functional languages. Note also that the commutativity property we establish in Sec.~\ref{sec:resumption} will not hold for a language that supports non-commutative effects. We leave to future work the task of defining more restricted special cases of commutativity in effectful settings.


The other major pillar of related work is the work on contextual modal type theory (CMTT) by \citet{Nanevski2008}, which we also discussed at length throughout the paper. To reiterate, there is a close relationship between expression holes in this paper and metavariables in CMTT. Hole contexts correspond to modal contexts.
Empty hole closures 
relate to the concept of a {metavariable closure} in CMTT, which consists
of a metavariable paired with a substitution for all of the variables in the
typing context associated with that metavariable. Hole filling relates to contextual substitution. 

Although these connections with gradual typing and CMTT are encouraging, our contributions do not neatly fall out from this prior work. The problem is first that \citet{Nanevski2008} defined only the logical reductions for CMTT, viewing it as a proof system for intuitionistic contextual modal logic via the propositions-as-types (Curry-Howard) principle. 
The paper therefore proved only a subject reduction property (which is closely related to type preservation). 
This is not a full dynamic semantics, and in particular, there is no notion of \emph{progress}, i.e. that well-typed terms cannot get ``stuck'' in an undefined state \cite{wright94:_type_soundness}. 
In any case, a conventional dynamic semantics for CMTT would not be immediately relevant to our goal of evaluating incomplete programs because, by our interpretation of hole closures, we would need a dynamic semantics for terms with free metavariables (and, of course, with casts, i.e. \emph{gradual contextual modal type theory}).

\citet{Nanevski2008} sketched an interpretation of CMTT into the simply-typed lambda calculus with sums under permutation conversion, %, 
which has been studied by \citet{DBLP:journals/iandc/Groote02}. 
Permutation conversions are necessary to encode the commuting reductions of CMTT, which in turn are necessary to prove a strong normalization property. 
These issues are not relevant in \HazelnutLive because, as in the gradually typed lambda calculus, type holes admit non-termination: we can express the Y combinator as $(\halam{x}{\tehole}{x(x)}) (\halam{x}{\tehole}{x(x)})$.
In any case, under this interpretation an analogous problem arises---metavariables become variables of a function type, so again we cannot rely on the standard notion of progress on closed terms. 

While there has been some formal work on reduction of open terms, leading to programs in a \emph{weak head normal form} \cite{barendregt84:_lambda_calculus,DBLP:journals/corr/abs-1009-2789}, there is no progress theorem in this setting nor is there environment tracking. Moreover, in the setting of an evaluator for a programming language, we do not want to evaluate under arbitrary binders but rather only around hole closures \cite{DBLP:conf/birthday/BlancLM05}. CMTT makes the appropriate distinctions between variables and metavariables, and our notion of an indeterminate form allows us to prove a progress theorem of familiar form. Weak head normal forms are more useful when using evaluation to perform optimizations throughout a program, e.g. when using supercompilation-by-evaluation \cite{DBLP:conf/haskell/BolingbrokeJ10} or symbolic evaluation \cite{King:1976}, or when using evaluation in the service of equational reasoning as in proof assistants (e.g. Beluga \cite{DBLP:journals/corr/abs-1009-2789}).

It is also worth emphasizing that we use the machinery 
borrowed from CMTT only extralinguistically.
%
A key feature of CMTT that we have not yet touched on is the
\emph{internalization} of metavariable binding and contextual
substitution via the contextual modal types, $[\hGamma]\htau$, which
are introduced by the operation $\mathsf{box}(\hGamma.d)$ and
eliminated by the operation $\mathsf{letbox}(d_1, u.d_2)$.
%
A hole filling can be interpreted as a value of contextual modal
type, and the act of hole filling followed by evaluation to the next
possibly-indeterminate edit state as evaluation under the binder of a
suitable $\mathsf{letbox}$ construct, which is enabled by the dynamic
semantics in Sec.~\ref{sec:calculus}.
%
This interpretation could be generalized to allow us to \emph{compute} a hole filling, rather
than simply stating it, by specifying a non-trivial expression, rather than just a value, of
modal type.
%
This could, in turn, serve as the basis for a \emph{live} computational hole
refinement system, extending the capabilities of purely static hole
refinement systems like those available in some proof assistants,
e.g. the elaborator reflection system of Idris
\cite{brady2013idris,DBLP:conf/icfp/ChristiansenB16} and the refinement system of Beluga
\cite{DBLP:conf/flops/Pientka10,pientka2015inductive}.
%
Each applied hole filling serves as a boundary between dynamic
\emph{edit stages}.
%
This contextual modal interpretation of live staged hole refinement
nicely mirrors the modal interpretation of staged argument evaluation
\cite{Davies:2001op}. 
%
This parallel neatly explains
the difference between our dynamics and existing work on staging and
partial evaluation---
existing staging and partial evaluation systems are focused on partial evaluation with respect to an input that sits outside of a
function \cite{Jones:1993uq}, whereas holes have non-trivial contexts.

There are various other systems similar in certain ways to CMTT in 
that they consider the problem of reasoning about metavariables. 
For example, McBride's OLEG is another system for reasoning contextually about metavariables
\cite{DBLP:phd/ethos/McBride00}, and it is the conceptual basis of certain hole refinement features in Idris \cite{brady2013idris}. \citet{DBLP:conf/csl/GeuversJ02} discuss similar ideas. CMTT is unique relative to prior approaches in that it has a clear Curry-Howard interpretation and that it was designed with commutativity properties in mind. This paper bears out that it is nicely suited for the purpose of live functional programming with typed expression holes.

Work on explicit substitutions confronts problems similar to the problem of tracking the environment around a closure using delayed substitutions \cite{Abadi:1991fr,levy1999explicit,Abadi:1990ys}.  \citet{DBLP:journals/corr/abs-1009-2789} have developed a theory of explicit substitutions for CMTT, which, following other work on explicit substitutions and environmental abstract machines \cite{DBLP:journals/tcs/Curien91}, would be useful in implementing \HazelnutLive more efficiently by delaying both standard and contextual substitutions until needed during evaluation. We leave this and other questions of fast implementation (e.g. using thunks to encapsulate indeterminate sub-expressions) to future work. 

% We also cannot rely on, for example, weak head normalization because \HazelnutLive admits non-termination (due to casts).\todo{citation} 

% Furthermore, we need to integrate casts into the dynamic semantics. 
% Fortunately, the dynamic semantics for the cast calculus from the gradually typed lambda calculus provides most, but not all, of the necessary machinery. 
% The first problem is again with progress: in the cast calculus, the only irreducible terms of hole type are casts, which are accounted for by the progress theorem, but in $\HazelnutLive$, holes induce additional irreducible terms. 
% The second missing piece is that in prior work on casts, evaluation aborts when cast failure occurs. 
% Our goal, as discussed in Sec.~\ref{sec:failed-cast-example}\todo{where?}{}, is for cast failure to instead insert a membrane around the dynamic type error, 
% much like a non-empty hole serves as a membrane around a static type error, 
% allowing in both cases for evaluation to safely and meaningfully continue past the error when desired.



% \begin{itemize}
	%% \item Agda
	%% \item Idris
	%% \item GHC holes
	%% \item Visual Studio (and others) support for edit-and-resume
	% \item Scratch lets you just skip over statement holes
	% \item papers that show up in a search for ``typed holes'' -- \url{https://scholar.google.com/scholar?hl=en&as_sdt=0%2C39&q=%22typed+holes%22&btnG=}
% \end{itemize}

% \parahead{Structure Editor Calculus}

Our approach is reminiscent of the workflow that debuggers make available using breakpoints \cite{fitzgerald2008debugging,DBLP:journals/jfp/TolmachA95}, visualizers of program state \cite{Nelson2017,Guo13}, and a variety of logging and tracing capabilities.
%
Debuggers do not directly support incomplete programs, so the programmer first needs to insert suitable dummy exceptions as discussed in Sec.~\ref{sec:intro}.
%
Beyond that, there are two main distinctions. First, evaluation does not stop at each breakpoint and so it is straightforward to explore the \emph{space} of values that a variable takes. Second, breakpoints, logs and tracing tools convey the values of a variable at a position in the evaluation trace. Hole closures, on the other hand, convey information from a syntactic position in the \emph{result} of evaluation. The result is, by nature, a simpler object. %  These approaches are fundamentally complementary in that standard debugging facilities are useful even when there are no holes in the program whereas our focus has been on incomplete programs. 
Some debuggers support ``edit-and-continue'', e.g. Visual Studio \cite{VSEditAndContinue} and Flutter \cite{flutter}, based on the dynamic software update (DSU) capabilities of the underlying run-time system \cite{DBLP:journals/toplas/StoyleHBSN07,DBLP:conf/vstte/HaydenMHFF12,DBLP:journals/toplas/HicksN05}. These features do not come with any guarantee that rerunning the program will produce the same result. The ``fill-and-resume'' feature described in Sec.~\ref{sec:resumption} is a special case that comes with this stronger guarantee.

Holes play a prominent role in structure editors, and indeed the prior work on \Hazelnut was primarily motivated by this application \cite{popl-paper}. 
Most work on structure editors has focused on the user interfaces that they
present. This is important work---presenting a fluid user interface involving
exclusively structural edit actions is a non-trivial problem that has not yet
been fully resolved, though recent studies have started to show productivity
gains for blocks-based structure editors like Scratch for novice programmers \cite{Resnick:2009:SP:1592761.1592779,DBLP:conf/chi/WeintropASFLSF18,DBLP:conf/acmidc/WeintropW15}, and for keyboard-driven structure
editors like \li{mbeddr} in professional programming settings~\cite{DBLP:conf/vl/Asenov014,DBLP:conf/sle/VolterSBK14,voelter_mbeddr:_2012}.
%
Some structure editors support live programming in various ways, e.g. Lamdu is a structure editor for a typed functional language that displays variable values inline based on recorded execution traces (see above) \cite{lamdu}. However, they do not generally support execution of incomplete programs, which was our focus in this paper. Scratch will execute a program with holes by simply skipping over incomplete commands, but this is a limited protocol because rerunning the program after filling the hole may produce a result unrelated to initial result in any way. Though in some situations, skipping over problematic commands has been observed to work surprisingly well \cite{DBLP:conf/dac/Rinard12}, this paper contributes a semantically sound approach (Sec.~\ref{sec:resumption}). Combined with the aforementioned UI advances, there is reason to believe that structure editing could be the foundation for a ``next-generation'' live programming experience. We emphasize, however,   
that our proposed contributions will be relevant no matter how holes come to appear (see Sec.~\ref{sec:intro}). % We will say more about all of these systems later. 

% two main remaining questions (beyond scaling up the calculus) are how to run
% programs with type and expression holes.

% \begin{itemize}
% 	\item Hazelnut paper
% \end{itemize}

% \parahead{Gradual Typing}

% As already discussed in Track 1, type holes are closely related to the unknown
% types of gradual type theory \cite{Siek06a}. This has implications for our
% dynamic semantics as well---we need to be able to run programs where type holes
% have obscured a type inconsistency, \eg{}~\lstinline{let f(g : }\ \lstinline{) => g 3 in f 4}.
% This term is well-typed according to the static semantics of Track 1 because the
% argument \li{g} of \li{f} has an unknown type, and so it can be applied to
% \li{3}, but when \li{f} is applied to \li{4}, there is a problem because \li{4 3}
% is meaningless. There are two ways to address the problem. The first is to
% apply ML-style type inference to discover a more specific type schema for
% \li{g}, \ie{}~that it must actually be an arrow type, and then mark the argument
% \li{4} to \li{f} as a type inconsistency using a non-empty hole. We will
% investigate this in Track 1. The second approach is to adopt run-time cast
% insertions from research on gradual type theory. We will investigate this second
% approach in Track 2. 

% \begin{itemize}
% 	\item gradual typing (and dynamic typing)
%   \item siek and taha paper
%   \item snapl15 paper
%   \item gradualizer paper
%   \item maybe other things, e.g. several papers by ron garcia
% \end{itemize}

A key feature of our semantics is that it permits evaluation not only of terms with empty holes, but also terms with non-empty holes, i.e. reified static type inconsistencies. 
Understanding and debugging static type errors is notoriously difficult,
particularly for novices.
%
A variety of approaches have been
proposed to better localize
and explain type errors \cite{Seminal,ChenErwig2014,Pavlinovic2015,sherrloc}.
%
One of these approaches, by \citet{Seidel2016},  uses symbolic execution and program synthesis to generate a dynamic witness
that demonstrates a run-time failure that could be caused by the static type error, and then displays a compressed evaluation
trace to the user as a graph.
%
\HazelnutLive{} has similar motivations in that it can run programs with static or dynamic type errors  and provide meaningful feedback about where ill-typed terms end up in the program, even after the first problem is encountered (Sec.~\ref{sec:static-errors}-\ref{sec:dynamic-type-errors}). However, no attempt is made to synthesize examples that do not already appear in the program. 
%
Combining the strengths of these approaches may be fruitful in the future. 

Expression holes also often appear in the context of program synthesis, serving as
placeholders in \emph{templates}~\cite{srivastava2013template} or
\emph{sketches}~\cite{solar2009sketching} to be filled in by an expression
synthesis engine. We leave to future work the possibility of combining these approaches, i.e. using the information generated by running an incomplete program as described in this paper to inform the generation of program and edit action suggestions, e.g. via tests or assertions that serve to generate constraints dynamically for type-and-example-driven synthesis \cite{DBLP:conf/popl/FrankleOWZ16}. 



% \begin{itemize}
% 	\item work on debuggers that allow you to inspect environments
%   \item might be something relevant in the paper ``A Debugger for Standard ML'' 
%   \item "Visualizing the evaluation of functional programs for debugging" by Whitington and Ridge
%   \item "A lightweight interactive debugger for Haskell'' and ``Multiple-View Tracing for Haskell: a New Hat'' might be relevant
%   \item ocamli -- \url{https://github.com/johnwhitington/ocamli}
%   \item Better supporting debugging aids learning a novel programming language. -- Scaffidi at VLHCC 2017
%   \item quote from Wadler in ``Why no one uses functional languages'':
%     \begin{quote}
%     â€œ...there are few debuggers or
% profilers for strict [functional] languages, perhaps because constructing them is not considered
% research. This is a shame, since such tools are sorely needed, and there remains much of
% interest to learn about their construction and use.
%     \end{quote}
%    \item edit-and-resume in visual studio, others
% \end{itemize}

% Visual Studio edit-and-continue \url{https://docs.microsoft.com/en-us/visualstudio/debugger/edit-and-continue}

Hole-like constructs also appear in work on program slicing
\cite{DBLP:conf/icfp/PereraACL12,DBLP:journals/pacmpl/RicciottiSPC17}, where empty expressions holes arise as a technical device to determine which parts of a complete program do not impact a selected part of the result of evaluating that program. In other words, the focus is on explaining a result that is presumed to exist, whereas the work in this paper is focused on producing results where they would not have otherwise been available. Combining the strengths of these approaches is another fruitful avenue for future research. 

% \begin{itemize}
% 	% \item simply typed underdeterminism paper
% 	% \item DuctileJ stuff -- \url{https://homes.cs.washington.edu/~mernst/pubs/ductile-icse2011.pdf}
% 	% \item ``Achieving flexibility in direct-manipulation programming environments by relaxing the edit-time grammar'' -- \url{http://ieeexplore.ieee.org/document/1509511/}
% 	\item 
% \end{itemize}



