% !TEX root = hazelnut-dynamics.tex
\newcommand{\relatedWorkSection}{Related and Future Work}
\section{\protect\relatedWorkSection} % don't like the all-caps thing that the template does, so protecting it from that
\label{sec:relatedWork}

This paper defined a dynamic semantics for incomplete functional programs
based directly on the static semantics developed by \citet{popl-paper}.
A subsequent ``vision paper'' introducing \Hazel suggested the need for 
a corresponding dynamic semantics for the purposes of live programming \cite{HazelnutSNAPL}. 
This paper    
contributes the type-theoretic first steps necessary to achieve this long-term vision.

The semantics borrows substantially
from the theory of type consistency and casts developed in gradual type theory \cite{Siek06a,DBLP:conf/snapl/SiekVCB15}, as discussed
at length in Sec.~\ref{sec:calculus}. The main innovation relative to this
prior work is the treatment of cast failures as holes, rather than errors.
Many of the methods developed to make gradual typing more expressive and practical are directly relevant to future directions for \Hazel and other implementations of the ideas herein. For example, there has been substantial work on the problem of implementing casts efficiently, e.g. by \citet{herman2010space}, and on integrating gradual typing with polymorphism, e.g. by \cite{garcia2015principal}. Another interesting direction that we leave to future work is the integration of these ideas into dependently typed proof assistants, 
where evaluation is at the service of equational reasoning.

Another important future direction is to move beyond
pure functional programming a la \Elm~ and carefully integrate imperative features, e.g. ML-style references. These require particular care, as recognized by \cite{Siek06a}, though we see no reason why the type safety properties  established in this paper would not be conserved in an effectful setting. Going beyond references to incorporate general effects, e.g. network and IO effects, raises some important practical concerns, however---we do not want to continue past a hole or error and in so doing haphazardly trigger an unintended effect. Developing language features and user interface features that give the programmer fine-grained control over evaluation when it encounters a hole or cast failure are likely to be particularly helpful in these settings.

The other major pillar of related work is the work on contextual modal type theory (CMTT) \cite{Nanevski2008}, which we also discussed at length throughout the paper. To reiterate, there is a close relationship between holes in this paper and metavariables in CMTT. Hole contexts correspond to modal contexts.
Empty hole closures 
relate to the concept of a \emph{metavariable closure} in CMTT, which consists
of a metavariable paired with a substitution for all of the variables in the
typing context associated with that metavariable. Hole filling relates to contextual substitution. 

Although these connections are encouraging, our contributions do not neatly fall out from the prior work. The problem is first that \citet{Nanevski2008} defined only the logical reductions for CMTT, viewing it as a proof system for intuitionistic contextual modal logic via the propositions-as-types (Curry-Howard) principle. 
The paper therefore proved only a subject reduction property (which is closely related to type preservation). 
This is not a full dynamic semantics, and in particular, there is no notion of \emph{progress}, i.e. that well-typed terms cannot get ``stuck'' in an undefined state \cite{wright94:_type_soundness}. 
In any case, a conventional dynamic semantics for CMTT would not be immediately relevant to our goal of evaluating incomplete programs because, by our interpretation of hole closures, we would need a dynamic semantics for terms with free metavariables. 
\citet{Nanevski2008} sketched an interpretation of CMTT into the simply-typed lambda calculus with sums under permutation conversion%
\footnote{Permutation conversions are necessary to encode the commuting reductions of CMTT, which in turn are necessary to prove a strong normalization property. These issues are not relevant in \HazelnutLive because, as in the gradually typed lambda calculus, type holes admit non-termination: we can express the Y combinator as $(\halam{x}{\tehole}{x(x)}) (\halam{x}{\tehole}{x(x)})$.}, 
which has been studied by \citet{DBLP:journals/iandc/Groote02}, 
but under this interpretation an analogous problem arises---metavariables become variables of a function type, so again we cannot rely on the standard notion of progress on closed terms.

It is also worth emphasizing that we use the machinery 
borrowed from CMTT extralinguistically.
%
However, a key feature CMTT that we have not yet touched on is the
\emph{internalization} of metavariable binding and contextual
substitution via the contextual modal types, $[\hGamma]\htau$, which
are introduced by the operation $\mathsf{box}(\hGamma.d)$ and
eliminated by the operation $\mathsf{letbox}(d_1, u.d_2)$.
%
A hole filling can be interpreted as an expression of contextual modal
type, and the act of hole filling followed by evaluation to the next
possibly-indeterminate edit state as evaluation under the binder of a
suitable $\mathsf{letbox}$ construct, which is enabled by the dynamic
semantics in Sec.~\ref{sec:calculus}.
%
This interpretation allows us to \emph{compute} hole fillings, rather
than simply stating them, by specifying non-trivial expressions of
modal type.
%
This could serve as the basis for a \emph{live} computational hole
refinement system, extending the capabilities of purely static hole
refinement systems like those available in some proof assistants,
e.g. the elaborator reflection system of Idris
\cite{brady2013idris,DBLP:conf/icfp/ChristiansenB16} and the refinement system of Beluga
\cite{DBLP:conf/flops/Pientka10,pientka2015inductive}.
%
Each applied hole filling serves as a boundary between dynamic
\emph{edit stages}.
%
This contextual modal interpretation of live staged hole refinement
nicely mirrors the modal interpretation of staged argument evaluation
\cite{Davies:2001op}.
%

Indeed, the connection to CMTT neatly explains
the difference between our proposed dynamics and existing work on staging and
partial evaluation---that existing work is rooted in modal type theory
\cite{Davies:2001op} rather than the derivative contextual modal type theory
(which, to date, has been studied far less extensively.) In other words,
existing systems are focused on partial evaluation with respect to an input that sits outside of a
function, whereas holes can appear in context, directly within the body of
a function. 

There are various other systems similar in various ways to CMTT in 
that they consider the problem of reasoning about metavariables. 
For example, McBride's OLEG is another system for reasoning contextually about metavariables
\cite{DBLP:phd/ethos/McBride00}, and it is the basis of certain analagous
features of Idris \cite{brady2013idris}. \citet{DBLP:conf/csl/GeuversJ02} discuss similar ideas. Work on explicit substitutions also confronts many related technical subtleties \cite{Abadi:1991fr,levy1999explicit,Abadi:1990ys}. CMTT is unique relative to prior approaches in that it was designed with commutativity properties in mind (though the theory was not fully developed).

Note that the commutativity property we establish will not hold for a language that supports non-commutative effects. We leave to future work the task of defining more restricted special cases of commutativity in effectful settings.

% We also cannot rely on, for example, weak head normalization because \HazelnutLive admits non-termination (due to casts).\todo{citation} 

% Furthermore, we need to integrate casts into the dynamic semantics. 
% Fortunately, the dynamic semantics for the cast calculus from the gradually typed lambda calculus provides most, but not all, of the necessary machinery. 
% The first problem is again with progress: in the cast calculus, the only irreducible terms of hole type are casts, which are accounted for by the progress theorem, but in $\HazelnutLive$, holes induce additional irreducible terms. 
% The second missing piece is that in prior work on casts, evaluation aborts when cast failure occurs. 
% Our goal, as discussed in Sec.~\ref{sec:failed-cast-example}\todo{where?}{}, is for cast failure to instead insert a membrane around the dynamic type error, 
% much like a non-empty hole serves as a membrane around a static type error, 
% allowing in both cases for evaluation to safely and meaningfully continue past the error when desired.



% \begin{itemize}
	%% \item Agda
	%% \item Idris
	%% \item GHC holes
	%% \item Visual Studio (and others) support for edit-and-resume
	% \item Scratch lets you just skip over statement holes
	% \item papers that show up in a search for ``typed holes'' -- \url{https://scholar.google.com/scholar?hl=en&as_sdt=0%2C39&q=%22typed+holes%22&btnG=}
% \end{itemize}

% \parahead{Structure Editor Calculus}

Holes play a prominent role in structure editors, and indeed the prior work on \Hazelnut was primarily motivated by this application. 
Most work on structure editors has focused on the user interfaces that they
present. This is important work---presenting a fluid user interface involving
exclusively structural edit actions is a non-trivial problem that has not yet
been fully resolved, though recent studies have started to show productivity
gains for keyboard-driven structure
editors~\cite{DBLP:conf/vl/Asenov014,DBLP:conf/sle/VolterSBK14}.
This work, together with the end-to-end well-definedness guarantee described in Sec.~\ref{sec:implementation}, suggests that structure editing together with live programming might be the foundation for a ``next-generation'' programming experience. We emphasize, however, 
that our proposed contributions will be relevant no matter how holes come to be
inserted into the program. % We will say more about all of these systems later. 

% two main remaining questions (beyond scaling up the calculus) are how to run
% programs with type and expression holes.

% \begin{itemize}
% 	\item Hazelnut paper
% \end{itemize}

% \parahead{Gradual Typing}

% As already discussed in Track 1, type holes are closely related to the unknown
% types of gradual type theory \cite{Siek06a}. This has implications for our
% dynamic semantics as well---we need to be able to run programs where type holes
% have obscured a type inconsistency, \eg{}~\lstinline{let f(g : }\ \lstinline{) => g 3 in f 4}.
% This term is well-typed according to the static semantics of Track 1 because the
% argument \li{g} of \li{f} has an unknown type, and so it can be applied to
% \li{3}, but when \li{f} is applied to \li{4}, there is a problem because \li{4 3}
% is meaningless. There are two ways to address the problem. The first is to
% apply ML-style type inference to discover a more specific type schema for
% \li{g}, \ie{}~that it must actually be an arrow type, and then mark the argument
% \li{4} to \li{f} as a type inconsistency using a non-empty hole. We will
% investigate this in Track 1. The second approach is to adopt run-time cast
% insertions from research on gradual type theory. We will investigate this second
% approach in Track 2. 

% \begin{itemize}
% 	\item gradual typing (and dynamic typing)
%   \item siek and taha paper
%   \item snapl15 paper
%   \item gradualizer paper
%   \item maybe other things, e.g. several papers by ron garcia
% \end{itemize}

Understanding and debugging static type errors is notoriously difficult,
particularly for novices.
%
A variety of approaches have been
proposed~\cite{Seminal,ChenErwig2014,Pavlinovic2015,sherrloc} to better localize
and explain type errors.
%
One of these approaches~\cite{Seidel2016} proposes to use program synthesis techniques to generate a dynamic witness
that demonstrates a run-time failure, and then display a compressed execution
trace to the user as a graph.
%
\HazelnutLive{} has similar motivations in that it can run programs with type errors (\ie{}, programs with
non-empty holes) as far as possible, in particular, until they
would go wrong, and provide meaningful feedback. However, no attempt is made to generate examples that do not already appear in the program. 
%
Combining the strengths of these approaches may be fruitful in the future. 

More generally, expression holes also often appear in the context of program synthesis, serving as
placeholders in \emph{templates}~\cite{srivastava2013template} or
\emph{sketches}~\cite{solar2009sketching} to be filled in by an expression
synthesis engine. We leave to future work the possibility of combining these approaches, i.e. using the information generated by running an incomplete program to inform the generation of program and edit action suggestions.

This approach is reminiscent of the workflow that debuggers make available using breakpoints \cite{fitzgerald2008debugging,DBLP:journals/jfp/TolmachA95} and various logging and tracing capabilities. 
The difference here is twofold. First, evaluation does not stop at each breakpoint and so it is straightforward to explore the \emph{space} of values that a variable takes. Second, breakpoints make available the values of a variable at a position in the evaluation trace. Hole closures, on the other hand, convey information from a syntactic position in the result of evaluation. The result is, by nature, a simpler object than the full evaluation trace that produced the result. These approaches are fundamentally complementary, rather than opposed.

% \begin{itemize}
% 	\item work on debuggers that allow you to inspect environments
%   \item might be something relevant in the paper ``A Debugger for Standard ML'' 
%   \item "Visualizing the evaluation of functional programs for debugging" by Whitington and Ridge
%   \item "A lightweight interactive debugger for Haskell'' and ``Multiple-View Tracing for Haskell: a New Hat'' might be relevant
%   \item ocamli -- \url{https://github.com/johnwhitington/ocamli}
%   \item Better supporting debugging aids learning a novel programming language. -- Scaffidi at VLHCC 2017
%   \item quote from Wadler in ``Why no one uses functional languages'':
%     \begin{quote}
%     â€œ...there are few debuggers or
% profilers for strict [functional] languages, perhaps because constructing them is not considered
% research. This is a shame, since such tools are sorely needed, and there remains much of
% interest to learn about their construction and use.
%     \end{quote}
%    \item edit-and-resume in visual studio, others
% \end{itemize}

% Visual Studio edit-and-continue \url{https://docs.microsoft.com/en-us/visualstudio/debugger/edit-and-continue}

Hole-like constructs also appear in work on program slicing
\cite{DBLP:conf/icfp/PereraACL12}, where holes are used as a technical device to determine which parts of the program that do not impact a selected part of the result.

% \begin{itemize}
% 	% \item simply typed underdeterminism paper
% 	% \item DuctileJ stuff -- \url{https://homes.cs.washington.edu/~mernst/pubs/ductile-icse2011.pdf}
% 	% \item ``Achieving flexibility in direct-manipulation programming environments by relaxing the edit-time grammar'' -- \url{http://ieeexplore.ieee.org/document/1509511/}
% 	\item 
% \end{itemize}



